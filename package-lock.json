//ABEDN adder;
// MIT License;
//Author - Yuri Spiridonov, ORCID 0000-0002-1260-8908;
//Code example in C++. The code implements binary decimal
//equivalents (ABEDN) arithmetic.
//See https://doi.org/10.36227/techrxiv.19294511.v2
//The binary Number _ BEDN is the binary equivalent
//of the decimal Number if the decimal value of Number _ BEDN
//has the same number of significant digits that can be
//trusted as Number.
//An example is given of adding the positive decimal numbers
//number1 and number2 represented by the binary equivalents
//of number1_BEDN and number2_BEDN in float. The binary sum
//S_number = number1_BEDN + number2_BEDN is correctly rounded
//to S_number_BEDN and compared bitwise to number3_BEDN, which
//is the binary equivalent of the decimal constant number3.
//The summation is carried out with decimal precision to N<=7
//significant digits, which can be trusted. The precision N is
//user-defined and is a global constant. The positive numbers
//number1 and number2 can have up to 7 decimal significant
//digits. These numbers are written in natural form or in
//scientific notation. Decimal input constants have a maximum
//decimal exponent of E=38.

#include <iostream>
#include <math.h>
#include <stdlib.h>
#include <iomanip>
using namespace std;

  int N=7;
float RoundB (float *num);

int main()
{
   float S_number,number1,number2,number3;
   float S_number_BEDN,number1_BEDN,number2_BEDN,number3_BEDN;

        number1 =  0.1E-21;
        number2 =  0.2E-21;
        number3 =  0.3E-21;
//Determination of binary equivalents of decimal numbers;
        number1_BEDN = RoundB(&number1);

        number2_BEDN = RoundB(&number2);

         number3_BEDN = RoundB(&number3);

     S_number = number1_BEDN + number2_BEDN;
     S_number_BEDN= RoundB(&S_number);

        if(S_number_BEDN ==number3_BEDN){
            cout<<endl <<"It's true "<<0<<'\n';
            return 0;
        }
        cout<<endl <<"It's false "<<0<<'\n';
             return 0;
   }
 ////////////////////////////////////////////////

  float RoundB (float *num){

   float B_Round,X;
   unsigned int N_C;
   int e,E,k;

//Exponent of binary equivalent of rounded decimal number;

            frexp (*num,&e);

//Number correction to disambiguate representation decimal X_number
//in binary form;

            X = *num+pow(2,(e-53));

 // Calculating the exponent of a decimal X_number;

          E =static_cast <int> ((e-1)*0.301+1);

// Decimal exponent correction for e<1 case;

        if (e<1)
        E = E-1;

// Calculating the rounding factor;

            k = N-E;

//Checking if the value of the rounded number needs to be corrected;

           if (abs(X*pow(10,k)) >= pow(10,N)){

           k = k-1;
}
// Calculating integer mantissa N_C for a rounded number;

          N_C =static_cast <unsigned int> (X*pow(10,k)+0.5);


// Converting a decimal rounded number to its binary equivalent;

       B_Round = N_C*pow(10,-k);

          return B_Round;
 }
